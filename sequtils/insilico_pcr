#!/usr/bin/env python3
# insilico_pcr
# search through fasta file for primer pairs and return coordinates
# regardless of primer length a match = 15bp. (this is the requirement from Jim Kents UCSC version)
# ejr: 2023-01-23
# lmd: 2023-02-01

import sys
import argparse
import signal

###############################################################################
### MAIN 
###############################################################################
def main():
    args = get_args()
    fasta = read_fasta(args.file)

    if args.reverse_complement is True:
        right_primer = reverse_complement(right_primer)
    else:
        right_primer = args.right_primer
    
    bed = primer_search(fasta, args.left_primer, right_primer, args.max_size)
    print_bed(bed)

###############################################################################
### Get command-line arguments using argparse
###############################################################################
def get_args():
    parser = argparse.ArgumentParser(description="Align primers to genome and retrieve product")
    # file defaults to stdin
    parser.add_argument('-f', '--file', type = argparse.FileType('r'), default = sys.stdin, help = 'Reference FASTA (genome or transcriptome) - defaults to STDIN')
    parser.add_argument('-l', '--left_primer', type = str, default = '0', help = 'Left primer sequence')
    parser.add_argument('-r', '--right_primer', type = str, default = '0', help = 'Right primer sequence')
    parser.add_argument('-rc', '--reverse_complement', action='store_true', help = 'Right primer needs to be flipped')
    parser.add_argument('-s', '--max_size', type = int, default = '10000', help = 'Maximum distance between primers')
    args = parser.parse_args()
    return args

###############################################################################
### Search FASTA for primers
###############################################################################
def primer_search(fasta, left_primer, right_primer, max_size): 
    bed = {} # contain amplification fragments
    left_bed = {} # contains just left primer matches

    ###### ALIGN LEFT PRIMERS ######
    for header in fasta:
        seqlen = len(fasta[header])
        left_len = len(left_primer)

        # scan sequence in primer size windows (step 1)
        for i in range(seqlen - left_len):
            matches = sum(a==b for a, b in zip(left_primer, fasta[header][i:i+left_len]))
            if matches >= 15:
                name = header + ":" + str(i) + "-" + str(i + left_len)
                left_bed[name] = {}
                left_bed[name]['start'] = i
                left_bed[name]['end'] = i + left_len
                left_bed[name]['chr'] = header
                left_bed[name]['strand'] = "+"
                left_bed[name]['score'] = matches

        # scan reverse-complement of sequence in primer size windows (step 1)
        left_primer = reverse_complement(left_primer)

        for i in range(seqlen - left_len):
            matches = sum(a==b for a, b in zip(left_primer, fasta[header][i:i+left_len]))
            if matches >= 15:
                name = header + ":" + str(i - left_len) + "-" + str(i)
                left_bed[name] = {}
                left_bed[name]['start'] = i 
                left_bed[name]['end'] = i + left_len
                left_bed[name]['chr'] = header
                left_bed[name]['strand'] = "-"
                left_bed[name]['score'] = matches

    ###### ALIGN RIGHT PRIMERS ######
    # for every left primer match we want to look Nbp downstream for a right match
    right_len = len(right_primer)


    for name in left_bed:
        if left_bed[name]['strand'] == "+":

            # We don't need to look beyond the end of the sequences
            if left_bed[name]['start'] + max_size < seqlen:
                end_pos = seqlen
            else:
                end_pos = left_bed[name]['start'] + max_size

            # forward matches
            for i in range(left_bed[name]['start'], end_pos):
                matches = sum(a==b for a, b in zip(right_primer, fasta[left_bed[name]['chr']][i:i+right_len]))
                
                if matches >= 15:
                    #print(rc[i:i+right_len])
                    right_name = left_bed[name]['chr'] + ":" + str(left_bed[name]['start']) + "-" + str(i+right_len)
                    bed[right_name] = {}
                    bed[right_name]['start'] =  left_bed[name]['start']
                    bed[right_name]['end'] = i + right_len
                    bed[right_name]['chr'] = left_bed[name]['chr']
                    bed[right_name]['strand'] = "+"
                    bed[right_name]['score'] = matches

        # reverse matches            
        seqlen = len(fasta[left_bed[name]['chr']])   
        if left_bed[name]['strand'] == "-":
            right_primer = reverse_complement(right_primer) # this might "unreverse" if rc is set, but that's what we want

            if left_bed[name]['start'] - max_size < 0:
                start_pos = 0
            else:
                start_pos = left_bed[name]['start'] - max_size


            #print (left_bed[name]['end'])
            for i in range(start_pos, left_bed[name]['end'] - left_len ):
                matches = sum(a==b for a, b in zip(right_primer, fasta[left_bed[name]['chr']][i:i+right_len]))
                #print(fasta[left_bed[name]['chr']][i:i+right_len])
                #print(matches)

                if matches >= 15:
                    right_name = left_bed[name]['chr'] + ":" + str(i) + "-" + str(left_bed[name]['end'])
                    bed[right_name] = {}
                    bed[right_name]['start'] =  i
                    bed[right_name]['end'] =  left_bed[name]['end']
                    bed[right_name]['chr'] = left_bed[name]['chr']
                    bed[right_name]['strand'] = "-"
                    bed[right_name]['score'] = matches

    return(bed)

###############################################################################
# Reverse Complement Sequence
###############################################################################
def reverse_complement(seq):
    # complement sequence
    bases = str.maketrans('AGCTagct','TCGAtcga')
    # reverse sequences; return
    return seq.translate(bases)[::-1]

###############################################################################
### Read FASTA filehandle into dictionary
###############################################################################
def read_fasta(fh):
    header = ""
    fasta = {}

    for line in fh:
        line = line.rstrip()
        # starts with handles blank lines better than line[0]
        if (line.startswith(">")):
            header = line[1:]
            fasta[header] = []
        else:
            fasta[header].append(line)
    # append is more efficient that string concatenation
    for header in fasta:
        fasta[header] = ''.join(fasta[header])

    return fasta

###############################################################################
### Print BED Dictionary as BED to STDOUT
###############################################################################
def print_bed(bed): 
    for name in bed:
        print("\t".join([bed[name]['chr'], str(bed[name]['start']), str(bed[name]['end']), name, str(bed[name]['score']), bed[name]['strand']]))

###############################################################################
### RUN MAIN 
###############################################################################
if __name__ == "__main__":
    # this catches sigpipe errors so you don't get an error message if you tail of head output
    signal.signal(signal.SIGFPE, signal.SIG_DFL)
    main()